package autoimage.gui.dialogs;

import autoimage.data.layout.Landmark;
import autoimage.data.Vec3d;
import autoimage.api.IAcqLayout;
import autoimage.api.BasicArea;
import autoimage.events.LandmarkSelectionChangedEvent;
import autoimage.events.StagePositionChangedEvent;
import autoimage.gui.models.LandmarkTableModel;
import com.google.common.eventbus.EventBus;
import com.google.common.eventbus.Subscribe;
import ij.IJ;
import java.awt.Frame;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.ListSelectionModel;
import javax.swing.SwingUtilities;
import javax.swing.event.ListSelectionEvent;
import javax.swing.event.ListSelectionListener;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import mmcorej.CMMCore;

/**
 *
 * @author Karsten Siller
 */
public class RefPointListDlg extends javax.swing.JDialog {

    private final CMMCore core;
    private final IAcqLayout acqLayout;
    private  List<Landmark> landmarksBackup;
    private String xyStageName;
    private String zStageName;
    private boolean modified;
    private final boolean privateEventBus;
    private final EventBus eventBus;
       
    private final static double TOLERANCE_SCALE_FACTOR = 0.05;
        
    public RefPointListDlg(Frame parent, CMMCore core, IAcqLayout aLayout, EventBus evtBus) {
        super(parent, false);
        //create copy of current landmarks to revert to in case dialog is cancelled 
        landmarksBackup=cloneLandmarks(aLayout.getLandmarks());  
        
        this.core=core;
        acqLayout=aLayout;
        
        initComponents();
        
        //set up landmark table and table listener
        landmarkTable.getTableHeader().setReorderingAllowed(false);
        final LandmarkTableModel model=LandmarkTableModel.createInstance(acqLayout);
        model.addTableModelListener(new TableModelListener() {
            @Override
            public void tableChanged(TableModelEvent e) {
                IJ.log("DIALOG TABLE CHANGED - Constructor: Type="+e.getType());
                updateStageRotAndTilt();    
                moveToButton.setEnabled(acqLayout.getNoOfMappedStagePos() > 0 );
                modified=true;
            }
        });
        landmarkTable.setModel(model);
        
        //set up landmark selection listener
        landmarkTable.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);        
        ListSelectionModel lsm = landmarkTable.getSelectionModel();
        lsm.addListSelectionListener(new ListSelectionListener() {
            @Override
            public void valueChanged(ListSelectionEvent e) {  
                if (!e.getValueIsAdjusting()) {
                    eventBus.post(new LandmarkSelectionChangedEvent(acqLayout, getSelectedRefAreas()));
                }
            }    
        });

        //get current stage position and display
        try {
            xyStageName=core.getXYStageDevice();
            zStageName=core.getFocusDevice();
            double stageX=core.getXPosition(xyStageName);
            double stageY=core.getYPosition(xyStageName);
            double stageZ=core.getPosition(zStageName);
            stagePositionChanged(new StagePositionChangedEvent(new Double[]{stageX, stageY, stageZ}));

            updateStageRotAndTilt();
        } catch (Exception ex) {
            Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
        } 

        //initialize misc gui elements
        messageLabel.setText("");
        moveToButton.setEnabled(acqLayout.getNoOfMappedStagePos() > 0 );

        //register for layout events
        acqLayout.registerForEvents(this);
        
        //set up eventBus to post dialog events to
        if (evtBus==null) {
            eventBus=new EventBus();
            privateEventBus=true;
        } else {
            eventBus=evtBus;
            privateEventBus=false;
        }
        this.setDefaultCloseOperation(DISPOSE_ON_CLOSE);
        modified=false;
    }

    public void registerForEvents(Object listener) {
        eventBus.register(listener);
    }
    
    public void unregisterForEvents(Object listener) {
        if (privateEventBus) {
            eventBus.unregister(listener);
        }
    }
   
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane1 = new javax.swing.JScrollPane();
        landmarkTable = new javax.swing.JTable();
        addButton = new javax.swing.JButton();
        removeButton = new javax.swing.JButton();
        okButton = new javax.swing.JButton();
        cancelButton = new javax.swing.JButton();
        jLabel1 = new javax.swing.JLabel();
        stagePosLabel = new javax.swing.JLabel();
        moveToButton = new javax.swing.JButton();
        updateStagePosButton = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        tiltLabel = new javax.swing.JLabel();
        jLabel2 = new javax.swing.JLabel();
        rotationLabel = new javax.swing.JLabel();
        messageLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Set Landmarks");
        setMinimumSize(new java.awt.Dimension(527, 300));
        addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosing(java.awt.event.WindowEvent evt) {
                formWindowClosing(evt);
            }
        });

        jScrollPane1.setViewportView(landmarkTable);

        addButton.setText("+");
        addButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                addButtonActionPerformed(evt);
            }
        });

        removeButton.setText("-");
        removeButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                removeButtonActionPerformed(evt);
            }
        });

        okButton.setText("OK");
        okButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okButtonActionPerformed(evt);
            }
        });

        cancelButton.setText("Cancel");
        cancelButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cancelButtonActionPerformed(evt);
            }
        });

        jLabel1.setText("Stage position:");

        stagePosLabel.setText("jLabel2");

        moveToButton.setText("Move to");
        moveToButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                moveToButtonActionPerformed(evt);
            }
        });

        updateStagePosButton.setText("Update Stage Pos");
        updateStagePosButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                updateStagePosButtonActionPerformed(evt);
            }
        });

        jLabel4.setText("Tilt (z-axis):");

        tiltLabel.setText("jLabel5");

        jLabel2.setText("Rotation (x-y plane):");

        rotationLabel.setText("jLabel3");

        messageLabel.setForeground(new java.awt.Color(255, 0, 0));
        messageLabel.setText("jLabel3");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(6, 6, 6)
                        .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 588, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(20, 20, 20)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(addButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(removeButton)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(moveToButton))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(jLabel4)
                                    .addComponent(jLabel2))
                                .addGap(6, 6, 6)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(rotationLabel, javax.swing.GroupLayout.DEFAULT_SIZE, 207, Short.MAX_VALUE)
                                    .addComponent(tiltLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addComponent(jLabel1)
                                .addGap(6, 6, 6)
                                .addComponent(stagePosLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 207, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addComponent(messageLabel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(okButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(updateStagePosButton, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(cancelButton, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
                .addGap(6, 6, 6))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(6, 6, 6)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 98, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(addButton)
                    .addComponent(removeButton)
                    .addComponent(moveToButton)
                    .addComponent(updateStagePosButton))
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(okButton)
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                        .addComponent(jLabel1)
                        .addComponent(stagePosLabel)))
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel2)
                    .addComponent(rotationLabel)
                    .addComponent(cancelButton))
                .addGap(6, 6, 6)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabel4)
                    .addComponent(tiltLabel))
                .addGap(6, 6, 6)
                .addComponent(messageLabel)
                .addGap(27, 27, 27))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    private void updateStageRotAndTilt() {
        int mappedPos=acqLayout.getNoOfMappedStagePos();
        if (mappedPos == 0) {
            tiltLabel.setText("unknown");
            rotationLabel.setText("unknown");     
        } else {
            try {    
                acqLayout.calcStageToLayoutTransform();
                tiltLabel.setText(String.format("%1$,.1f",acqLayout.getTilt())+" degree");
                AffineTransform at=acqLayout.getStageToLayoutTransform();
                double angle=acqLayout.getStageToLayoutRot();
                                
                //move to listener?
                BasicArea.setStageToLayoutRot(angle);
                Landmark.Builder.setStageToLayoutRot(angle);
                
                
                angle=angle/Math.PI*180;
                if (angle > 180) angle=angle-360;
                rotationLabel.setText(String.format("%1$,.1f",angle)+" degree");
                String message="";
                List<Landmark> mappedList=acqLayout.getMappedLandmarks();
                if (mappedPos == 2) {
                    Landmark r0=mappedList.get(0);
                    Landmark r1=mappedList.get(1);
                    double sx=r1.getStageCoordX()-r0.getStageCoordX();
                    double sy=r1.getStageCoordY()-r0.getStageCoordY();
                    double sl=Math.sqrt(sx*sx+sy*sy);
                    double dx=r1.getLayoutCoordX()-r0.getLayoutCoordX();
                    double dy=r1.getLayoutCoordY()-r0.getLayoutCoordY();
                    double dl=Math.sqrt(dx*dx+dy*dy);
                    if (Math.abs(dl/sl - 1) > TOLERANCE_SCALE_FACTOR) {
                        message="Warning: Uniform scaling factor is "+String.format("%1$,.2f",dl/sl)+" (exceeding "+(100*TOLERANCE_SCALE_FACTOR)+"% tolerance)";
                    }
                } else if (mappedPos==3) {
                    Landmark r0=mappedList.get(0);
                    Landmark r1=mappedList.get(1);
                    Landmark r2=mappedList.get(2);
                    double s01x=r1.getStageCoordX()-r0.getStageCoordX();
                    double s01y=r1.getStageCoordY()-r0.getStageCoordY();
                    double s01l=Math.sqrt(s01x*s01x+s01y*s01y);
                    double d01x=r1.getLayoutCoordX()-r0.getLayoutCoordX();
                    double d01y=r1.getLayoutCoordY()-r0.getLayoutCoordY();
                    double d01l=Math.sqrt(d01x*d01x+d01y*d01y);

                    double s02x=r2.getStageCoordX()-r0.getStageCoordX();
                    double s02y=r2.getStageCoordY()-r0.getStageCoordY();
                    double s02l=Math.sqrt(s02x*s02x+s02y*s02y);
                    double d02x=r2.getLayoutCoordX()-r0.getLayoutCoordX();
                    double d02y=r2.getLayoutCoordY()-r0.getLayoutCoordY();
                    double d02l=Math.sqrt(d02x*d02x+d02y*d02y);

                    double s21x=r1.getStageCoordX()-r2.getStageCoordX();
                    double s21y=r1.getStageCoordY()-r2.getStageCoordY();
                    double s21l=Math.sqrt(s21x*s21x+s21y*s21y);
                    double d21x=r1.getLayoutCoordX()-r2.getLayoutCoordX();
                    double d21y=r1.getLayoutCoordY()-r2.getLayoutCoordY();
                    double d21l=Math.sqrt(d21x*d21x+d21y*d21y);
                    if (Math.abs(d01l/s01l - 1) > TOLERANCE_SCALE_FACTOR
                            || Math.abs(d21l/s21l - 1) > TOLERANCE_SCALE_FACTOR
                            ||Math.abs(d02l/s02l - 1) > TOLERANCE_SCALE_FACTOR) {
                        if (Math.abs(d01l/s01l - d21l/s21l) < 0.01
                               && Math.abs(d01l/s01l - d02l/s02l) < 0.01
                               && Math.abs(d02l/s02l - d21l/s21l) < 0.01) {
                            message="Warning: Uniform scaling factor is "+String.format("%1$,.2f",d01l/s01l)+" (exceeding "+(100*TOLERANCE_SCALE_FACTOR)+"% tolerance)";
                        } else {
                            message="Warning: Non-uniform scaling and shearing.";                              
                        }
                    }
                }
                messageLabel.setText(message);
            } catch (Exception ex) {
                tiltLabel.setText("Error");
                rotationLabel.setText("Error");
                Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
//                IJ.log(getClass().getName()+": affineTransform: "+ex.getMessage());
                JOptionPane.showMessageDialog(null, ex.getMessage());
            }
        }
    }
    
    private List<Landmark> cloneLandmarks(List<Landmark> list) {
        ArrayList<Landmark> clonedList = new ArrayList<Landmark>(list.size());
        for (Landmark r : list) {
            clonedList.add(r.copy().build());
        }
        return clonedList;
    }
    
    private void updateStagePosButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_updateStagePosButtonActionPerformed
        int row=landmarkTable.convertRowIndexToModel(landmarkTable.getSelectedRow());
        if (row>=0) {
            LandmarkTableModel model=(LandmarkTableModel)landmarkTable.getModel();
            try {
                double stageX=core.getXPosition(xyStageName);
                double stageY=core.getYPosition(xyStageName);
                double stageZ=core.getPosition(zStageName);
                for (int i=0; i<model.getRowCount(); i++) {
                    Landmark landmark=model.getRowData(i);
                    if (i!=row 
                            && landmark.isStagePosMapped() 
                            && Math.round(landmark.getStageCoordX())==Math.round(stageX)
                            && Math.round(landmark.getStageCoordY())==Math.round(stageY)
                            && Math.round(landmark.getStageCoordZ())==Math.round(stageZ)) {
                        JOptionPane.showMessageDialog(this, "A Reference Point is already defined for this stage position!");   
                        return;
                    }
                }
                model.setStagePos(row, stageX, stageY, stageZ);
            } catch (Exception ex) {
                Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
            }
        } else
            JOptionPane.showMessageDialog(this, "No Reference Point selected.");
    }//GEN-LAST:event_updateStagePosButtonActionPerformed

    private void moveToButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_moveToButtonActionPerformed
        int row=landmarkTable.getSelectedRow();
        if (row>=0) {
            LandmarkTableModel model=(LandmarkTableModel)landmarkTable.getModel();
            Landmark refArea=model.getRowData(row);
            if (!refArea.isStagePosMapped()) {
                JOptionPane.showMessageDialog(this, "Stage position not mapped. Cannot move to this landmark.");
                return;
            }
            try {
                double stageX=(Double)model.getValueAt(row,1);
                double stageY=(Double)model.getValueAt(row,2);
                double stageZ=(Double)model.getValueAt(row,3);
                core.waitForDevice(zStageName);
                core.setPosition(zStageName,acqLayout.getEscapeZPos());
                core.waitForDevice(xyStageName);
                core.setXYPosition(xyStageName, stageX, stageY);
                core.waitForDevice(zStageName);
                core.setPosition(zStageName,stageZ);
            } catch (Exception ex) {
                Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
            }
            
        } else
            JOptionPane.showMessageDialog(this, "No Reference Point selected.");
    }//GEN-LAST:event_moveToButtonActionPerformed

    private void addButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_addButtonActionPerformed
        LandmarkTableModel model=(LandmarkTableModel)landmarkTable.getModel();
        List<Landmark> landmarks=model.getLandmarks();
        if (model.getRowCount()>=3) {
            JOptionPane.showMessageDialog(this, "Cannot create more than three Reference Points.");
            return;
        }    
        try {
            double stageX=core.getXPosition(xyStageName);
            double stageY=core.getYPosition(xyStageName);
            double stageZ=core.getPosition(zStageName);
            for (Landmark landmark:landmarks) {
                if (stageX==landmark.getStageCoordX() && stageY==landmark.getStageCoordY() && stageZ==landmark.getStageCoordZ()) {
                    JOptionPane.showMessageDialog(this, "Stage position already in list.");
                    return;
                }
            }
            if (landmarks.size()>1) {
                Vec3d rp1=new Vec3d(landmarks.get(0).getStageCoordX(), landmarks.get(0).getStageCoordY(), 0);
                Vec3d rp2=new Vec3d(landmarks.get(1).getStageCoordX(), landmarks.get(1).getStageCoordY(), 0);
                Vec3d newrp=new Vec3d(stageX,stageY,0);
                if (Vec3d.cross(newrp.minus(rp1),newrp.minus(rp2)).length() == 0) {
                    JOptionPane.showMessageDialog(this,"Cannot add current stage position as new Reference Point!\nThe new x-y stage position is colinear with x-y stage positions of existing Reference Points.");
                    return;
                }    
            }       
            Landmark.Builder landmarkBuilder=new Landmark.Builder()
                    .setName("Landmark")
                    .setStageCoord(stageX, stageY, stageZ)
                    .setPhysDimension(core.getPixelSizeUm()*core.getImageWidth(), core.getPixelSizeUm()*core.getImageHeight())
                    .setStagePosMapped(true);
            if (model.getRowCount()>0) {
                //convert xy stage pos to xy layout pos; z pos in layout will be initialized with '0'
                Point2D lPoint=acqLayout.convertStageToLayoutPos_XY(new Point2D.Double(stageX, stageY));
                landmarkBuilder.setLayoutCoord(lPoint.getX(), lPoint.getY(), 0);
            } else {
                //first landmark: initialize x-y-z layout pos with (0/0/0)
                landmarkBuilder.setLayoutCoord(0, 0, 0);
            }
            model.addLandmark(landmarkBuilder.build());
        } catch (Exception ex) {
//            IJ.log(getClass().getName()+": addLandmark: "+ex.getMessage());
            Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_addButtonActionPerformed

    private void cancelButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cancelButtonActionPerformed
        if (modified) {
            int answer = JOptionPane.showConfirmDialog(this, "Do you want to discard the modified Landmark definitions?","", JOptionPane.YES_NO_OPTION);
            if (answer==JOptionPane.YES_OPTION) {
                acqLayout.setLandmarks(landmarksBackup);
            }
        }
        dispose();
    }//GEN-LAST:event_cancelButtonActionPerformed

    private void okButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okButtonActionPerformed
        try {
            acqLayout.calcStageToLayoutTransform();
        } catch (Exception ex) {
            Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
        }
        eventBus.post(new LandmarkSelectionChangedEvent(acqLayout,null));
        if (modified) 
            acqLayout.setModified(true);
        dispose();
    }//GEN-LAST:event_okButtonActionPerformed

    private void removeButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_removeButtonActionPerformed
        int row=landmarkTable.convertRowIndexToModel(landmarkTable.getSelectedRow());
        if (row>=0) {
            try {
                LandmarkTableModel model=(LandmarkTableModel)landmarkTable.getModel();
                if (model.deleteLandmark(row) == null) {
                    JOptionPane.showMessageDialog(this, "Landmark cannot be removed.");
                }
            } catch (Exception ex) {
//                IJ.log(getClass().getName()+": removeLandmark: "+ex.getMessage());
                Logger.getLogger(RefPointListDlg.class.getName()).log(Level.SEVERE, null, ex);
            }
        } 
    }//GEN-LAST:event_removeButtonActionPerformed

    private void formWindowClosing(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowClosing
        if (modified) {
            int answer = JOptionPane.showConfirmDialog(this, "Do you want to keep the modified Landmark definitions?","", JOptionPane.YES_NO_OPTION);
            if (answer==JOptionPane.NO_OPTION) {
                acqLayout.setLandmarks(landmarksBackup);
            }
        }
        eventBus.post(new LandmarkSelectionChangedEvent(acqLayout,null));
    }//GEN-LAST:event_formWindowClosing

    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton addButton;
    private javax.swing.JButton cancelButton;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JTable landmarkTable;
    private javax.swing.JLabel messageLabel;
    private javax.swing.JButton moveToButton;
    private javax.swing.JButton okButton;
    private javax.swing.JButton removeButton;
    private javax.swing.JLabel rotationLabel;
    private javax.swing.JLabel stagePosLabel;
    private javax.swing.JLabel tiltLabel;
    private javax.swing.JButton updateStagePosButton;
    // End of variables declaration//GEN-END:variables


    @Subscribe
    public void stagePositionChanged(final StagePositionChangedEvent e) {
        SwingUtilities.invokeLater(new Runnable() {     
            @Override
            public void run() {
                stagePosLabel.setText(
                      (e.getStageX()!=null ? String.format("%1$,.2f",e.getStageX()) : "???") + "; "
                    + (e.getStageY()!=null ? String.format("%1$,.2f",e.getStageY()) : "???") + "; "
                    + (e.getStageX()!=null ? String.format("%1$,.2f",e.getStageZ()) : "???"));
            }
        });    
    }

    private List<Landmark> getSelectedRefAreas() {
        List<Landmark> selected=new ArrayList<Landmark>();
        int[] viewRows=landmarkTable.getSelectedRows();
        LandmarkTableModel model=(LandmarkTableModel)landmarkTable.getModel();
        for (int viewIndex:viewRows) {
            Landmark r=model.getRowData(landmarkTable.convertRowIndexToModel(viewIndex));
            selected.add(r);
        }
        return selected;
    }

    public void setAcqLayout(IAcqLayout acqLayout) {
        landmarksBackup=cloneLandmarks(acqLayout.getLandmarks());  
        modified=false;
        LandmarkTableModel model=(LandmarkTableModel)landmarkTable.getModel();
        model.setAcqLayout(acqLayout);
        updateStageRotAndTilt();
    }
    
}
